# AVL Tree Test Data - Lab 8
# This file contains specific test datasets for AVL tree operations and rotations
# Lines starting with # are comments

# =====================================================
# SINGLE ROTATION TEST DATA
# =====================================================

# Right Rotation (RR) - Left-Left Case
# Insert these in order to trigger right rotation
RIGHT_ROTATION_SIMPLE:
30 20 10

RIGHT_ROTATION_WITH_SUBTREES:
50 30 70 20 40 10

# Left Rotation (LL) - Right-Right Case  
# Insert these in order to trigger left rotation
LEFT_ROTATION_SIMPLE:
10 20 30

LEFT_ROTATION_WITH_SUBTREES:
30 10 50 40 60 70

# =====================================================
# DOUBLE ROTATION TEST DATA
# =====================================================

# Left-Right Rotation (LR) - Left-Right Case
# Insert these in order to trigger left-right rotation
LEFT_RIGHT_ROTATION_SIMPLE:
30 10 20

LEFT_RIGHT_ROTATION_COMPLEX:
50 20 70 10 30 25

# Right-Left Rotation (RL) - Right-Left Case
# Insert these in order to trigger right-left rotation  
RIGHT_LEFT_ROTATION_SIMPLE:
10 30 20

RIGHT_LEFT_ROTATION_COMPLEX:
20 10 40 50 30 35

# =====================================================
# SEQUENTIAL INSERTION TEST DATA
# =====================================================

# These test AVL's ability to maintain balance with worst-case BST input
SEQUENTIAL_ASCENDING:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

SEQUENTIAL_DESCENDING:
15 14 13 12 11 10 9 8 7 6 5 4 3 2 1

SEQUENTIAL_LARGE:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31

# =====================================================
# MULTIPLE ROTATION SCENARIOS
# =====================================================

# This data will trigger multiple different types of rotations
MIXED_ROTATIONS:
50 25 75 10 30 60 80 5 15 27 35 55 65 70 85 3 7 12 18 24 28 32 37

# Fibonacci-like pattern that creates interesting balance scenarios
FIBONACCI_PATTERN:
1 1 2 3 5 8 13 21 34 55 89

# Powers of 2 pattern
POWERS_OF_TWO:
1 2 4 8 16 32 64 128 256 512

# =====================================================
# DELETION WITH REBALANCING TEST DATA
# =====================================================

# Build this tree, then delete nodes in specified order
DELETE_TEST_BUILD:
50 25 75 10 30 60 80 5 15 27 35 55 65 70 85

DELETE_TEST_ORDER:
5 10 15 80 85 70

# Another deletion scenario
DELETE_SCENARIO_2_BUILD:
100 50 150 25 75 125 175 10 30 60 90 110 140 160 190

DELETE_SCENARIO_2_ORDER:
10 30 190 175 160

# =====================================================
# HEIGHT ANALYSIS TEST DATA
# =====================================================

# Perfect binary tree structure (for comparison)
PERFECT_BINARY_TREE:
8 4 12 2 6 10 14 1 3 5 7 9 11 13 15

# Data that creates maximum AVL height for given number of nodes
MAX_HEIGHT_AVL_15_NODES:
8 4 12 2 6 10 14 1 5 9 13 3 11 7 15

# Data that creates minimum AVL height  
MIN_HEIGHT_AVL_15_NODES:
8 4 12 2 6 10 14 1 3 5 7 9 11 13 15

# =====================================================
# STRESS TEST DATA
# =====================================================

# Large dataset for performance testing
STRESS_TEST_100:
50 25 75 12 37 62 87 6 18 31 43 56 68 81 93 3 9 15 21 28 34 40 46 53 59 65 71 78 84 90 96 1 4 7 10 13 16 19 22 26 29 32 35 38 41 44 47 51 54 57 60 63 66 69 72 76 79 82 85 88 91 94 97 2 5 8 11 14 17 20 23 27 30 33 36 39 42 45 48 52 55 58 61 64 67 70 73 77 80 83 86 89 92 95 98 99 100

# Random pattern for balanced insertion testing
RANDOM_BALANCED:
347 189 672 45 298 543 789 123 267 421 598 734 856 912 76 234 398 567 698 823 91 156 289 445 612 756 891 34 145 278 356 489 634 723 867 945

# Alternating high-low pattern
ALTERNATING_PATTERN:
500 1 499 2 498 3 497 4 496 5 495 6 494 7 493 8 492 9 491 10

# =====================================================
# SPECIFIC ROTATION VERIFICATION DATA
# =====================================================

# Each section below creates a specific imbalance that should trigger exactly one rotation type

# Guaranteed Right Rotation Trigger
# After inserting all values, tree should have exactly one right rotation
FORCE_RIGHT_ROTATION:
100 80 120 60 90 110 130 40 70 50

# Guaranteed Left Rotation Trigger  
# After inserting all values, tree should have exactly one left rotation
FORCE_LEFT_ROTATION:
100 80 120 60 90 110 130 140 150 160

# Guaranteed Left-Right Rotation Trigger
# The specific pattern that forces LR rotation
FORCE_LEFT_RIGHT_ROTATION:
100 50 150 25 75 65

# Guaranteed Right-Left Rotation Trigger
# The specific pattern that forces RL rotation  
FORCE_RIGHT_LEFT_ROTATION:
100 50 150 125 175 135

# =====================================================
# EDGE CASE TEST DATA
# =====================================================

# Single node operations
SINGLE_NODE:
42

# Two node scenarios
TWO_NODES_LEFT:
10 5

TWO_NODES_RIGHT:
10 15

# Three node scenarios (minimal trees for each rotation)
THREE_NODES_BALANCED:
10 5 15

THREE_NODES_LEFT_HEAVY:
15 10 5

THREE_NODES_RIGHT_HEAVY:
5 10 15

# Duplicate value testing
DUPLICATES:
50 25 75 25 50 75 10 10 90 90

# Negative numbers
NEGATIVE_VALUES:
0 -10 10 -20 -5 5 20 -15 -3 3 15

# Large values near integer limits
EXTREME_VALUES:
2147483647 -2147483648 1000000000 -1000000000 0 1 -1

# =====================================================
# BALANCE FACTOR VERIFICATION DATA
# =====================================================

# These datasets help verify balance factor calculations

# Should create nodes with balance factor +1 (left heavy but balanced)
BALANCE_FACTOR_PLUS_ONE:
10 5 15 3 6

# Should create nodes with balance factor -1 (right heavy but balanced)  
BALANCE_FACTOR_MINUS_ONE:
10 5 15 12 18

# Should create nodes with balance factor 0 (perfectly balanced)
BALANCE_FACTOR_ZERO:
10 5 15

# Pattern that creates various balance factors
MIXED_BALANCE_FACTORS:
50 25 75 10 30 60 80 5 15 27 35 55 65 70 85

# =====================================================
# HEIGHT CALCULATION VERIFICATION DATA
# =====================================================

# Known height outcomes for verification
HEIGHT_0_TREE:
42

HEIGHT_1_TREE:
10 5

HEIGHT_2_TREE:
10 5 15 3

HEIGHT_3_TREE:
10 5 15 3 7 12 18

# Tree that should maintain specific height after AVL balancing
CONTROLLED_HEIGHT_TEST:
16 8 24 4 12 20 28 2 6 10 14 18 22 26 30 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31

# =====================================================
# COMPLEX SCENARIO TEST DATA
# =====================================================

# Scenario 1: Insert in order, then delete every other element
COMPLEX_SCENARIO_1_INSERT:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16

COMPLEX_SCENARIO_1_DELETE:
2 4 6 8 10 12 14 16

# Scenario 2: Build balanced tree, then insert sequential elements
COMPLEX_SCENARIO_2_BASE:
50 25 75 12 37 62 87

COMPLEX_SCENARIO_2_SEQUENTIAL:
1 2 3 4 5 6 7 8 9 10 11

# Scenario 3: Alternating insert/delete operations
COMPLEX_SCENARIO_3_OPERATIONS:
# INSERT: 50, 25, 75, DELETE: 25, INSERT: 30, 20, DELETE: 75, INSERT: 80, 10
50 25 75 -25 30 20 -75 80 10
# Note: Negative numbers indicate deletions in this scenario

# =====================================================
# PERFORMANCE COMPARISON DATA
# =====================================================

# Best case for regular BST (same as AVL best case)
BST_BEST_CASE:
50 25 75 12 37 62 87 6 18 31 43 56 68 81 93

# Worst case for regular BST (should be balanced by AVL)
BST_WORST_CASE:
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15

# Average case for comparison
BST_AVERAGE_CASE:
8 3 10 1 6 14 4 7 13 9 11 2 5 12 15

# =====================================================
# CUSTOM TEST INSTRUCTIONS
# =====================================================
#
# Usage Examples:
#
# 1. Testing Right Rotation:
#    AVLTree tree = new AVLTree();
#    int[] values = {30, 20, 10}; // RIGHT_ROTATION_SIMPLE
#    for (int v : values) tree.insert(v);
#    // Verify: root should be 20, left=10, right=30
#
# 2. Testing Sequential Insertion:
#    int[] seq = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15}; // SEQUENTIAL_ASCENDING
#    // Regular BST height would be 14, AVL should be ~4
#
# 3. Complex Rotation Testing:
#    int[] mixed = {50,25,75,10,30,60,80,5,15,27,35,55,65,70,85,3,7,12,18,24,28,32,37};
#    // Should trigger multiple different rotation types
#
# 4. Performance Analysis:
#    Compare insertion time and final height between:
#    - BST with BST_WORST_CASE data
#    - AVL with BST_WORST_CASE data  
#    - Both should be similar with BST_BEST_CASE data
#
# 5. Balance Factor Verification:
#    After building tree with BALANCE_FACTOR_PLUS_ONE:
#    // Root (10) should have BF = +1
#    // Node 5 should have BF = 0  
#    // Node 15 should have BF = -1
#
# =====================================================